好的，这是一个非常实用的功能，类似于模板变量替换。在您现有的项目基础上实现它完全可行。下面我将为您提供详细的修改思路、步骤和关键要点。

### 整体思路

我们将采用以下架构来实现此功能：

1.  **状态管理**：在主应用结构体 `MyApp` 中添加新的状态变量，用于管理“赋值窗口”的开关、存储找到的标记（例如 `{{投标公司}}`）以及它们对应的新值。
2.  **UI 触发**：在顶部菜单栏添加一个按钮（例如“模板赋值”），点击后触发标记提取和赋值窗口的显示。
3.  **标记提取**：当用户点击按钮时，程序将使用**正则表达式**扫描整个编辑区文本，找出所有 `{{...}}` 格式的独特标记。
4.  **赋值窗口**：弹出一个新的 `egui` 窗口，该窗口会动态地根据找到的标记列表，为每一个标记生成一行“标签 + 输入框”。
5.  **文本替换**：当用户在赋值窗口中点击“全部替换”后，程序将遍历所有标记及其新值，在编辑区的全文中执行替换操作，然后关闭赋值窗口。

-----

### 实现步骤

#### 步骤 1：修改应用状态（`MyApp` 结构体）

首先，我们需要在 `MyApp` 结构体中添加新的字段来管理此功能的状态。

**位置**：`main.rs` -\> `struct MyApp { ... }`

**操作**：添加以下三个字段：

```rust
struct MyApp {
    markdown_text: String,
    cache: egui_commonmark::CommonMarkCache,
    // ... 其他已有字段 ...
    
    // --- 新增字段 ---
    /// 控制赋值窗口是否显示
    assignment_window_open: bool,
    /// 存储从文本中提取出的所有独特标记，例如 "{{投标公司}}"
    template_markers: Vec<String>,
    /// 使用 HashMap 存储每个标记及其对应的用户输入值
    marker_values: std::collections::HashMap<String, String>,
}
```

并且，在 `main` 函数初始化 `MyApp` 的地方，为这些新字段提供默认值：

```rust
// main 函数中
let app = MyApp {
    // ... 其他已有字段的初始化 ...
    assignment_window_open: false,
    template_markers: Vec::new(),
    marker_values: std::collections::HashMap::new(),
};
```

#### 步骤 2：添加 UI 触发按钮

在顶部菜单栏添加一个按钮来启动此功能。

**位置**：`main.rs` -\> `fn update` -\> `egui::TopBottomPanel`

**操作**：可以创建一个新的“工具”菜单，并在其中添加按钮。

```rust
// 在 update 方法的菜单栏部分
// ... "文件" 和 "视图" 菜单旁边 ...
ui.menu_button("工具", |ui| {
    if ui.button("模板赋值").clicked() {
        // 调用一个新方法来处理后续逻辑
        self.open_assignment_window();
        ui.close();
    }
});
```

#### 步骤 3：实现标记提取逻辑

现在，创建 `open_assignment_window` 方法。这个方法的核心是使用正则表达式来查找所有标记。

**注意**：这需要您添加一个新的依赖项。请打开 `Cargo.toml` 文件，在 `[dependencies]` 部分添加 `regex` crate：

```toml
[dependencies]
# ... 其他依赖 ...
regex = "1"
```

**位置**：`main.rs` -\> `impl MyApp { ... }`

**操作**：添加新方法 `open_assignment_window`。

```rust
// impl MyApp 内部
use regex::Regex; // 在文件顶部或 impl 外部引入
use std::collections::HashSet;

impl MyApp {
    // ... 其他方法 ...

    fn open_assignment_window(&mut self) {
        // 1. 定义正则表达式来匹配 {{...}}
        //    - \{\{ 匹配两个左大括号
        //    - ([^}]+?) 匹配一个或多个非右大括号的字符（非贪婪模式）
        //    - \}\} 匹配两个右大括号
        let re = Regex::new(r"\{\{([^}]+?)\}\}").unwrap();
        
        // 2. 使用 HashSet 来自动去重，确保每个标记只出现一次
        let mut unique_markers = HashSet::new();
        for mat in re.find_iter(&self.markdown_text) {
            unique_markers.insert(mat.as_str().to_string());
        }
        
        // 3. 将独特标记存入 Vec 以便在 UI 中稳定排序显示
        self.template_markers = unique_markers.into_iter().collect();
        self.template_markers.sort(); // 可选：按字母顺序排序

        // 4. 初始化每个标记的值为空字符串
        self.marker_values.clear();
        for marker in &self.template_markers {
            self.marker_values.insert(marker.clone(), String::new());
        }

        // 5. 最后，打开窗口
        self.assignment_window_open = true;
    }
}
```

#### 步骤 4：创建并显示赋值窗口

在主 `update` 函数中，根据 `assignment_window_open` 状态来决定是否显示新窗口。

**位置**：`main.rs` -\> `fn update`

**操作**：在 `egui::CentralPanel` 的外部（或内部的起始位置）添加窗口渲染逻辑。

```rust
// 在 update 方法中
fn update(&mut self, ctx: &egui::Context, _frame: &mut Frame) {
    // ... 快捷键处理 和 TopBottomPanel ...
    
    // --- 新增代码：渲染赋值窗口 ---
    if self.assignment_window_open {
        self.show_assignment_window(ctx);
    }
    // --- 新增代码结束 ---
    
    egui::CentralPanel::default().show(ctx, |ui| {
        // ... 原有的 CentralPanel 内容 ...
    });
}

// 同样在 impl MyApp 中，添加 show_assignment_window 方法
impl MyApp {
    // ... 其他方法 ...
    
    fn show_assignment_window(&mut self, ctx: &egui::Context) {
        egui::Window::new("模板变量赋值")
            .open(&mut self.assignment_window_open) // 允许用户通过点击 'x' 关闭窗口
            .resizable(true)
            .default_width(400.0)
            .show(ctx, |ui| {
                // 如果没有找到标记，显示提示信息
                if self.template_markers.is_empty() {
                    ui.label("在文档中没有找到 {{...}} 格式的标记。");
                    return;
                }

                ui.label("请为以下标记赋新值：");
                ui.add_space(10.0);

                // 使用滚动区域，以防标记过多
                egui::ScrollArea::vertical().show(ui, |ui| {
                    // 使用网格布局，让标签和输入框对齐
                    egui::Grid::new("assignment_grid").num_columns(2).show(ui, |ui| {
                        for marker in &self.template_markers {
                            ui.label(marker);
                            // 关键：将 TextEdit 绑定到 HashMap 中对应的值
                            if let Some(value) = self.marker_values.get_mut(marker) {
                                ui.text_edit_singleline(value);
                            }
                            ui.end_row();
                        }
                    });
                });

                ui.add_space(10.0);
                ui.separator();
                
                // --- 步骤 5 的替换逻辑在这里实现 ---
                ui.horizontal(|ui| {
                    if ui.button("全部替换").clicked() {
                        // 执行替换
                        for (marker, value) in &self.marker_values {
                            if !value.is_empty() { // 只替换已赋值的
                                self.markdown_text = self.markdown_text.replace(marker, value);
                            }
                        }
                        // 关闭窗口并清理状态
                        self.assignment_window_open = false;
                        self.template_markers.clear();
                        self.marker_values.clear();
                    }

                    if ui.button("取消").clicked() {
                        self.assignment_window_open = false;
                    }
                });
            });
    }
}
```

### 注意要点

1.  **添加依赖**：最重要的一点是不要忘记在 `Cargo.toml` 中添加 `regex` 依赖。
2.  **正则表达式**：我提供的正则表达式 `r"\{\{([^}]+?)\}\}"` 是安全且常用的，`+?` 表示非贪婪匹配，可以正确处理一行内有多个标记的情况。
3.  **UI 布局**：在赋值窗口中，使用 `egui::Grid` 可以让标签和输入框整齐对齐，`egui::ScrollArea` 则可以确保在标记数量很多时窗口依然可用。
4.  **状态绑定**：将 `egui::TextEdit` 与 `HashMap` 中的值绑定的技巧是 `self.marker_values.get_mut(marker)`，这确保了用户的输入被正确地存储。
5.  **替换逻辑**：`String::replace` 会返回一个新的 `String`，因此需要将其赋值回 `self.markdown_text`。循环替换是简单有效的方式。
6.  **状态清理**：在替换完成或取消后，将 `assignment_window_open` 设为 `false` 并清理 `template_markers` 和 `marker_values` 是一个好习惯，可以防止旧数据影响下一次操作。

按照以上步骤，您就可以在现有项目中成功集成这个强大的模板赋值功能。