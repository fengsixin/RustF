好的，为 Pandoc 导出功能添加自定义模板选择是一个非常专业且实用的增强。这能让用户根据自己的需求（例如公司报告模板、学校论文格式）来控制输出文档的样式。

我们将在您现有的异步导出架构基础上，无缝地集成这个新功能。

### 整体思路

1.  **状态管理**：在 `MyApp` 结构体中增加一个字段，用于存储用户选择的 `.docx` 模板文件的路径。这个字段将是 `Optional` 的，因为用户可能不选择任何模板，此时 Pandoc 会使用其默认样式。
2.  **UI 交互**：在“文件”菜单中，我们将添加一个新的按钮“设置导出模板...”，点击后会弹出文件选择框。同时，我们还会提供一个清晰的视觉反馈，显示当前已选择的模板文件名，并允许用户清除该选择。
3.  **逻辑修改**：修改 `export_as_docx` 方法，使其在创建后台转换线程时，将模板文件的路径（如果已设置）一同传递过去。
4.  **命令构建**：在后台线程中，动态地构建 Pandoc 命令。如果模板路径存在，就在命令中添加 `--reference-doc=<模板文件路径>` 参数。

-----

### 详细实现步骤

#### 步骤一：在 `MyApp` 结构体中添加模板路径状态

**位置**：`main.rs` -\> `struct MyApp { ... }`

**操作**：添加 `reference_doc_path` 字段。

```rust
struct MyApp {
    // ... 已有字段 ...
    conversion_receiver: Option<crossbeam_channel::Receiver<Result<String, String>>>,
    // --- 新增字段 ---
    /// 存储用户选择的 Pandoc 参考文档（模板）的路径
    reference_doc_path: Option<std::path::PathBuf>,
}
```

*别忘了在 `main` 函数的 `MyApp` 初始化中，为它设置默认值 `reference_doc_path: None,`。*

#### 步骤二：在 UI 中添加入口和状态显示

我们需要在“文件”菜单中让用户可以设置和查看模板。

**位置**：`main.rs` -\> `fn update` -\> 文件菜单 `ui.menu_button("文件", ...)` 内部。

**操作**：在“导出为 DOCX”按钮下方，添加模板设置的相关 UI。

```rust
ui.menu_button("文件", |ui| {
    // ... 打开、保存、合并、导出的按钮 ...
    if ui.button("导出为 DOCX").clicked() {
        ui.close();
        self.export_as_docx();
    }
    
    // --- 新增代码开始 ---
    ui.separator(); // 添加一条分割线，视觉上更清晰

    if ui.button("设置导出模板...").clicked() {
        ui.close();
        self.set_reference_doc();
    }

    // 如果用户已经设置了模板，则显示它并提供清除选项
    if let Some(path) = &self.reference_doc_path {
        ui.horizontal(|ui| {
            // 只显示文件名，路径太长会不好看
            let filename = path.file_name()
                .map(|s| s.to_string_lossy())
                .unwrap_or_default();
            
            ui.label(format!("当前模板: {}", filename));

            // 添加一个小的 "x" 按钮来清除模板
            if ui.button("清除").clicked() {
                self.reference_doc_path = None;
                ui.close();
            }
        });
    }
    // --- 新增代码结束 ---
});
```

#### 步骤三：实现设置模板的逻辑

现在，我们需要创建 `set_reference_doc` 方法。

**位置**：`main.rs` -\> `impl MyApp { ... }` 内部。

```rust
impl MyApp {
    // ... 其他方法 ...

    // --- 新增方法 ---
    fn set_reference_doc(&mut self) {
        let handle = rfd::FileDialog::new()
            .add_filter("Word 文档", &["docx"])
            .set_title("选择一个 DOCX 模板文件")
            .pick_file();
            
        if let Some(path) = handle {
            // 用户选择了文件，我们就保存它的路径
            self.reference_doc_path = Some(path);
        }
    }
}
```

#### 步骤四：修改 `export_as_docx` 方法以传递模板路径

这是最关键的一步，我们需要把模板信息传递到后台线程。

**位置**：`main.rs` -\> `impl MyApp` -\> `fn export_as_docx` 方法内部。

**操作**：在启动线程前，克隆模板路径，并将其 `move` 进线程闭包。

```rust
fn export_as_docx(&mut self) {
    // ... 防止重复点击的检查 ...
    // ... 获取 output_path ...

    let (sender, receiver) = crossbeam_channel::unbounded();
    self.conversion_receiver = Some(receiver);
    let markdown_content = self.markdown_text.clone();
    
    // --- 新增：克隆模板路径以传递给线程 ---
    let reference_doc = self.reference_doc_path.clone();

    std::thread::spawn(move || {
        // ... 创建和写入临时文件的逻辑 ...

        let pandoc_path = /* ... 动态查找 pandoc 路径的逻辑 ... */;

        // --- 修改：动态构建 Pandoc 命令 ---
        let mut command = Command::new(pandoc_path);
        
        command.arg(temp_file.path())
               .arg("-o")
               .arg(&output_path); // 注意这里最好用引用

        // 如果存在参考文档路径，则添加到命令参数中
        if let Some(ref_path) = reference_doc {
            command.arg("--reference-doc").arg(ref_path);
        }

        let pandoc_output = command.stdout(Stdio::piped())
                                 .stderr(Stdio::piped())
                                 .output();

        // ... 后续处理 pandoc_output 和发送结果的逻辑 ...
        
        let _ = sender.send(result);
    });
}
```

### 功能说明与注意要点

1.  **什么是 Pandoc 模板文件？**

      * 一个有效的 Pandoc 模板（`reference-doc`）**不是**一个包含内容的普通 `.docx` 文件。它是一个**只包含样式**的 `.docx` 文件。
      * **制作方法**：您可以拿一个 Pandoc 默认生成的 `.docx` 文件，用 Word 打开它，修改其中的“样式”（例如，修改“标题 1”、“正文”的字体、颜色、间距等），然后**删除所有内容**，只保留一个空段落，另存为一个新的 `.docx` 文件。这个新文件就是您的模板。

2.  **用户体验**：

      * 通过在 UI 上清晰地显示当前模板并提供“清除”按钮，用户可以很方便地管理他们的导出设置。
      * 将模板选择与导出操作分离，允许用户“一次设置，多次使用”，符合工作流习惯。

3.  **代码健壮性**：

      * `Option<PathBuf>` 的使用确保了代码的健壮性，可以优雅地处理用户设置或不设置模板两种情况。
      * 动态构建 `Command` 的方式是处理可选命令行参数的标准做法。

完成以上修改后，您的 Markdown 编辑器将具备一个非常专业和强大的功能，极大地提升了其实用价值。