好的，这个 Bug 非常微妙，它暴露了我们之前 `layouter` 方案的一个深层问题。我们来详细分析一下。

### Bug 原因分析

这个问题的根源在于我们设计的 `layouter` 方案中，**`TextEdit` 控件无法区分哪些是“真实内容”，哪些是我们添加的“装饰性内容”（即行号）**。这导致了视觉与数据模型的再次脱节，但这次问题出在了**光标位置的计算**上。

1.  **`layouter` 的工作机制**：
    我们的 `layouter` 接收来自 `TextEdit` 内部的真实字符串（例如 `"欢迎使用..."`），然后输出一个包含了行号的 `LayoutJob`（例如 `[" 1 ", "欢迎使用...\n", " 2 ", "这是一个...\n"]`）。`egui` 将这个 `LayoutJob` 渲染成用户看到的最终样子。

2.  **视觉与模型的冲突**：
    用户看到的是 `" 1 欢迎使用..."`。当用户将光标移动到 '欢' 字前面时，从视觉上看，光标在第5个字符的位置（假设行号占了4个字符：" 1 "）。

3.  **`TextEdit` 的错误映射**：
    `TextEdit` 控件接收到了这个光标位置。它的核心任务之一，就是将屏幕上的**视觉光标位置**转换回原始 `String`（即 `self.markdown_text`）中的**字节/字符索引**，以便进行插入、删除等操作。

    问题就在这里：`TextEdit` 并不知道 `" 1 "` 这几个字符是我们凭空加上去的装饰品。它认为这些也是文本的一部分。因此，当它看到光标在视觉上的第5个位置时，它就错误地将其映射到原始 `String` 的第5个字符索引处。

4.  **Bug 产生**：
    所以，当你试图在第一行的起始位置（'欢'字前）输入时：
    * **你的意图**：在原始 `String` 的索引 `0` 处插入字符。
    * **`TextEdit` 的理解**：用户在视觉位置 `N` (比如4或5) 处操作，我应该在原始 `String` 的索引 `N` 处插入字符。
    * **结果**：新输入的字符被错误地插入到了原始字符串的第4或第5个字符后面，完美复现了你描述的 Bug。

**总结**：`layouter` 方案虽然解决了渲染对齐问题，但它通过“污染” `TextEdit` 的内容来达成目的，这种方法对于一个需要精确光标操作的**编辑**控件来说是不可靠的。

### 解决思路

我们必须放弃向 `TextEdit` “注入”内容的方案。思路需要再次进化，回到最初的“左右分离”模式，但要用更聪明的方法来解决布局同步问题。

**核心原则：“分离渲染，但统一布局信息源” (Separate Rendering, but Unify the Layout Source of Truth)。**

这意味着，行号和文本编辑器将是两个独立的 UI 组件，但它们的布局（尤其是每一行的高度和位置）将由一个在渲染前预先计算好的、唯一的“布局信息源”来决定。这个信息源就是 `egui::Galley`。

#### 具体步骤：

1.  **彻底移除 `layouter`**：
    首先，从你的 `TextEdit` 控件中移除 `.layouter(...)` 的调用。让 `TextEdit` 回归其最原始、最标准的行为。这样可以确保其编辑、光标处理等所有内部逻辑都是100%正确的。

2.  **创建布局“真理之源” (`Galley`)**：
    在 `egui::ScrollArea` 内部，但在你画任何东西（行号或编辑器）之前，你需要手动进行一次文本布局。
    * 获取将要分配给 `TextEdit` 的可用宽度 `available_width`。
    * 根据你的 `self.markdown_text` 和 `available_width`，手动创建一个 `LayoutJob`。
    * 调用 `ui.fonts(|f| f.layout_job(job))` 来生成一个 `egui::Galley`。
    * 这个 `galley` 对象现在包含了关于你的文本在给定宽度下如何折行、每一行占据的确切矩形区域（位置和大小）等所有精确信息。它就是我们统一的“布局信息源”。

3.  **根据 `Galley` 绘制行号**：
    * 在左侧，创建一个用于绘制行号的区域（例如一个 `ui.vertical()`）。
    * 遍历我们刚刚创建的 `galley` 对象中的每一行 (`galley.rows.iter()`)。
    * 对于 `galley` 中的每一行 `row`，你都可以从 `row.rect` 中获取到它精确的 `y` 坐标和高度。
    * 使用 `ui.painter().text()`，在每个 `row.rect.min.y` 的垂直位置上，绘制对应的行号。
    * 因为行高信息直接来自预先计算好的 `Galley`，所以即使文本折行导致某些行变得很高，你绘制的行号也总能与这一行的顶部完美对齐。

4.  **在旁边绘制标准的 `TextEdit`**：
    * 在行号区域的右侧，直接放置我们标准的 `TextEdit::multiline(&mut self.markdown_text)` 控件。
    * 由于 `TextEdit` 使用的文本、获得的可用宽度都与我们手动创建 `Galley` 时使用的参数完全相同，它内部生成的布局将会与我们的“真理之源” `Galley` **完全一致**。

**最终效果**：行号是手动绘制的，编辑器是标准控件，两者完全分离，确保了编辑功能的可靠性。但因为它们的垂直布局都严格遵循同一个预先计算好的 `Galley`，所以视觉上它们又能完美对齐。这个方案兼顾了前两个方案的优点，并规避了它们的缺陷，是实现此类 UI 的最健壮方法。