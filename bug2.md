好的，我们来整体性地分析一下这两个 Bug，它们看似是两个独立的问题，但实际上是同一个核心问题的不同表现。理解了这一点，统一的解决方案就非常清晰了。

### 整体问题回顾与根源分析

你遇到的这两个 Bug，本质上都源于**试图将一个复杂的、自带内部逻辑的控件（`egui::TextEdit`）与一个外部的、手动的UI系统（你自己的行号绘制逻辑）进行“缝合”而导致的冲突**。

#### Bug 1：行号高度错位

* **现象**：行号与发生自动折行的文本内容无法对齐。
* **直接原因**：你手动绘制行号时，基于一个“所有行高度都相等”的**错误假设**。你用一个固定的 `row_height` 去计算行号的 `y` 坐标，但这与 `TextEdit` 内部为了处理长文本折行而动态计算出的实际行高不符。
* **根本原因**：**“渲染与布局的分离”**。行号的渲染逻辑（你的 `for` 循环和 `painter` 调用）与 `TextEdit` 的内容布局逻辑是完全独立的两个系统。它们各自为政，没有统一的协调机制，一旦遇到动态变化（如折行），必然产生不一致。

#### Bug 2：行尾编辑错位

* **现象**：在使用 `layouter` 解决了高度问题后，在行尾输入字符，字符会跑到下一行。
* **直接原因**：你在 `layouter` 中使用了 `string.lines()` 迭代器。这个迭代器会**丢弃**每行末尾的换行符 `\n`。你随后又手动地将 `\n` 作为一个独立的 `Fragment` 添加回 `LayoutJob`。
* **根本原因**：**“视觉表现与数据模型的不匹配”**。`TextEdit` 控件不仅负责显示，还负责处理用户的输入、光标移动等交互。它的这些交互逻辑**强依赖于**它所管理的原始 `String` 数据模型与最终渲染出来的 `Galley`（由 `layouter` 生成的布局产物）之间存在着清晰、一致的映射关系。

    当你把一行 `"内容\n"` 拆分成 `["内容", "\n"]` 两个独立的 `Fragment` 时，虽然**看起来**是对的，但你破坏了这种映射。`TextEdit` 在处理行尾输入时，无法准确地将屏幕上的光标位置映射回原始 `String` 中 `\n` 前的位置，从而导致逻辑混乱，将新字符错误地插入到了 `\n` 之后。

**总结一下**：
第一个方案败在了**布局**上（外部布局跟不上内部布局），第二个方案败在了**数据模型**上（改造后的视觉模型与原始数据模型脱钩）。

### 统一的、健壮的解决思路

要想完美解决这个问题，我们的方案必须同时满足两个条件：
1.  **布局统一**：行号和内容的布局必须由**同一个系统**（`egui` 的布局引擎）统一管理，以解决高度对齐问题。
2.  **模型一致**：`layouter` 生成的视觉布局 (`Galley`) 必须在结构上**最大程度地忠实于**原始的 `String` 数据模型，以保证编辑功能的正确性。

基于此，最终的、统一的解决思路如下：

**核心原则：在 `layouter` 中，将每一“行”（包含其末尾的换行符）视为一个不可分割的原子单位进行处理。**

#### 具体实现步骤：

1.  **坚定地使用 `layouter`**：
    这是正确的方向。所有手动计算行高、宽度，并使用 `ui.painter()` 绘制行号的代码都应该被彻底删除。这是解决 Bug 1 的前提。

2.  **弃用 `string.lines()` 迭代器**：
    这是 Bug 2 的根源，必须替换掉。我们的目标是获取每一行的内容，但**绝不能丢弃**它末尾的 `\n`。

3.  **实现一个“保留换行符”的行迭代逻辑**：
    你需要自己实现一个循环来遍历整个字符串 `buffer`。这个循环的逻辑不是简单地按 `\n` 分割，而是：
    * 从字符串的某个位置开始，向后查找下一个 `\n` 的字节位置。
    * 如果找到了，那么从开始位置到这个 `\n`（**包含** `\n` 本身）的切片就是完整的一行。
    * 如果没找到，那么从开始位置到字符串末尾的切片就是最后一行。
    * 重复这个过程，直到处理完整个字符串。

4.  **构建“原子化”的 `LayoutJob`**：
    在 `layouter` 中，使用上面实现的新的行迭代逻辑。对于得到的**每一段包含换行符的完整行 `line_slice`**：
    * **首先**，`append` 一个代表行号的 `TextFragment`（例如，文本为 `"{:<4} "`, 颜色为灰色）。
    * **其次**，`append` 另一个 `TextFragment`，其内容就是你刚刚切分出的**完整的 `line_slice`**。
    * 这样，`LayoutJob` 中的每一行都由 `[行号, 内容+\n]` 这两个紧密绑定的 `Fragment` 构成。由于 `\n` 始终跟在它的内容后面，`TextEdit` 的内部逻辑就不会再混淆。

通过这个方法，你既利用了 `egui` 的统一布局能力解决了**高度对齐**问题，又通过保持行的“原子性”维护了数据模型的一致性，解决了**编辑错位**的问题，从而达成一个稳定、健壮的最终方案。